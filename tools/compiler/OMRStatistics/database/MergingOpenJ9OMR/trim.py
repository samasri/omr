# This script takes an SQL file (generated by the makefile) and makes sure to enforce any UNIQUE constraints on it. Depending on the filename, which is the same as the table name, the script will apply the right constraints)

import sys

filename = sys.argv[1]
file = open(sys.argv[1],'r')
fileAgain = open(sys.argv[1],'r') # File need to be processed twice
write = open(sys.argv[1] + '.trimmed','w')

keySet = {}
classIDMapping = {}
functionIDMapping = {}

def saveClassIDMapping():
	w = open('classIDMapping.csv', 'w')
	for id in classIDMapping:
		w.write(id + "," + classIDMapping[id] + "\n")

def loadClassIDMapping():
	r = open('classIDMapping.csv', 'r')
	for row in r:
		if not row: continue
		row = row.split(',')
		classIDMapping[int(row[0])] = int(row[1].strip())

def saveFunctionIDMapping():
	w = open('functionIDMapping.csv', 'w')
	for id in functionIDMapping:
		w.write(id + "," + functionIDMapping[id] + "\n")

def loadFunctionIDMapping():
	r = open('functionIDMapping.csv', 'r')
	for row in r:
		if not row: continue
		row = row.split(',')
		functionIDMapping[int(row[0])] = int(row[1].strip())

if filename == 'File.sql':
	maxLocationSize = -1
	for row in fileAgain:
		for row in fileAgain:
			if 'Location VARCHAR' in row: 
				locationSize = int(row[row.index('(') + 1:row.index(')')])
				if maxLocationSize < locationSize: maxLocationSize = locationSize
	
	rc = 0
	for row in file: 
		rc += 1
		if rc < 7: 
			if 'Location VARCHAR' in row:
				locationSize = row[row.index('('):row.index(')') + 1]
				newRow = row.replace(locationSize,'(' + str(maxLocationSize) + ')')
				write.write(newRow)
				continue
			write.write(row)
		if row[:6] == 'INSERT': write.write(row)

if filename == 'Class.sql':
	# Find namespace and className sizes
	maxNamespaceSize = -1
	maxClassNameSize = -1
	for row in fileAgain:
		if 'Namespace VARCHAR' in row: 
			nameSpaceSize = int(row[row.index('(') + 1:row.index(')')])
			if maxNamespaceSize < nameSpaceSize: maxNamespaceSize = nameSpaceSize
		if 'ClassName VARCHAR' in row: 
			classNameSize = int(row[row.index('(') + 1:row.index(')')])
			if maxClassNameSize < classNameSize: maxClassNameSize = classNameSize
	
	rc = 0
	for row in file:
		# Keep one `CREATE` statement, with the largest namespace size and classname size
		rc += 1
		if rc < 10:
			if 'Namespace VARCHAR' in row: 
				nameSpaceSize = row[row.index('('):row.index(')') + 1]
				newRow = row.replace(nameSpaceSize,'(' + str(maxNamespaceSize) + ')')
				write.write(newRow)
				continue
			if 'ClassName VARCHAR' in row: 
				classNameSize = row[row.index('('):row.index(')') + 1]
				newRow = row.replace(classNameSize,'(' + str(maxClassNameSize) + ')')
				write.write(newRow)
				continue
			write.write(row)
			continue
		if row[:6] != 'INSERT': continue
		# Get info from row
		query = row[row.index('(') + 2 : row.rfind(')') - 1]
		query = query.split("','")
		id = query[0]
		namespace = query[1]
		clas = query[2]
		key = namespace + '-->' + clas
		# Make sure (namespace, className) are not redundant (issue #51)
		if key in keySet:
			# Keep track of removed IDs and what IDs are they duplicate of (issue #51)
			classIDMapping[id] = keySet[key]
			continue
		keySet[key] = id
		# Write the row to the file
		write.write(row)
	saveClassIDMapping();

if filename == 'Function.sql':
	temp = open('temp', 'w')
	loadClassIDMapping()
	# Find namespace and className sizes
	maxFunctionNameSize = -1
	maxSigSize = -1
	for row in fileAgain:
		if 'FunctionName VARCHAR' in row: 
			functionNameSize = int(row[row.index('(') + 1:row.index(')')])
			if maxFunctionNameSize < functionNameSize: 
				maxFunctionNameSize = functionNameSize
		if 'Signature VARCHAR' in row: 
			sigSize = int(row[row.index('(') + 1:row.index(')')])
			if maxSigSize < sigSize: maxSigSize = sigSize
	
	rc = 0
	for row in file:
		rc += 1
		# Keep one `CREATE` statement, with the largest function name size and signature size
		if rc < 15:
			if 'FunctionName VARCHAR' in row: 
				functionNameSize = row[row.index('('):row.index(')') + 1]
				newRow = row.replace(functionNameSize,'(' + str(maxFunctionNameSize) + ')')
				write.write(newRow)
				continue
			if 'Signature VARCHAR' in row: 
				sigSize = row[row.index('('):row.index(')') + 1]
				newRow = row.replace(sigSize,'(' + str(maxSigSize) + ')')
				write.write(newRow)
				continue
			write.write(row)
		if row[:6] != 'INSERT': continue
		
		# Get info from row
		query = row[row.index('(') + 2 : row.rfind(')') - 1]
		query = query.split("','")
		id = query[0]
		classID = int(query[3])
		
		wasReplaced = 0
		# Replace duplicate ClassIDs with the duplicated ClassID (issue #51)
		if classID in classIDMapping:
			row = row.replace("'" + str(classID) + "'", "'" + str(classIDMapping[classID]) + "'")
			# reload the query object for further analysis
			query = row[row.index('(') + 2 : row.rfind(')') - 1]
			query = query.split("','")
			classID = query[3]
			wasReplaced = 1
		
		# Check for duplicate (signature, classID) (issue #51)
		sig = query[2]
		key = str(classID) + "::" + sig
		if key in keySet: 
			# Keep track of removed IDs and what IDs are they duplicate of (issue #51)
			functionIDMapping[id] = keySet[key]
			temp.write(id + ',' + keySet[key] + '\n')
			continue
		keySet[key] = id
		write.write(row)
	saveFunctionIDMapping()

if filename == "Override.sql":
	temp = open('temp', 'r')
	repMap = {}
	for row in temp:
		if not row: continue
		split = row.split(',')
		repMap[split[0].strip()] = split[1].strip()
		
	loadFunctionIDMapping()
	rc = 0
	for row in file:
		rc += 1
		if rc < 9: write.write(row)
		if row[:6] != 'INSERT': continue
		# Get info from row
		query = row[row.index('(') + 2 : row.rfind(')') - 1]
		query = query.split("','")
		baseFunctionID = int(query[0])
		overridingFunctionID = int(query[1])
		# Replace duplicate ClassIDs with the duplicated ClassID (issue #51)
		changed = 0
		if baseFunctionID in functionIDMapping: 
			changed = 1 
			row = row.replace("'" + str(baseFunctionID) + "'", "'" + str(functionIDMapping[baseFunctionID]) + "'")
		if overridingFunctionID in functionIDMapping: 
			changed = 1
			row = row.replace("'" + str(overridingFunctionID) + "'", "'" + str(functionIDMapping[overridingFunctionID]) + "'")
		
		if changed:
			
			if str(baseFunctionID) in repMap and str(overridingFunctionID) in repMap: 
				print 'BaseFunctionID: ' + str(baseFunctionID) + ' --> ' + str(functionIDMapping[baseFunctionID])
				print 'OverridingFunctionID: ' + str(overridingFunctionID) + ' --> ' + str(functionIDMapping[overridingFunctionID])
				print '---------------------'
			query = row[row.index('(') + 2 : row.rfind(')') - 1]
			query = query.split("','")
			baseFunctionID = int(query[0])
			overridingFunctionID = int(query[1])
		
		# Check the uniqueness of (baseFunctionID, overridingFunctionID)
		key = str(baseFunctionID) + ',' + str(overridingFunctionID)
		if key in keySet: continue
		keySet[key] = 1
		
		write.write(row)

if filename == 'Hierarchy.sql':
	rc = 0
	for row in file:
		rc += 1
		if rc < 8: write.write(row)
		if row[:6] == 'INSERT': write.write(row)

if filename == 'Polymorphism.sql':
	rc = 0
	for row in file:
		rc += 1